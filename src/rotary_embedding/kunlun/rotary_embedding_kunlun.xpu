#include "kunlun/common_kernel_kunlun.h"

template <typename T, typename Tindex>
__global__ void RoPEKernel(T *destination, const T *source, 
                const Tindex *pos_ids, const T *sin_table, const T *cos_table, 
                kunlun_size_t seqlen,  kunlun_size_t nhead, kunlun_size_t dhead,
                kunlun_ptrdiff_t x_stride_seqlen, kunlun_ptrdiff_t x_stride_nhead,
                kunlun_ptrdiff_t y_stride_seqlen, kunlun_ptrdiff_t y_stride_nhead,
                XPUStream stream){
    //ndim = 3
    kunlun_size_t other_size = seqlen * nhead;

    int cid = core_id();
    int ncores = core_num();
    if (cid >= ncores) {
        return;
    }
    int thread_id = ncores * cluster_id() + cid;
    int nthreads = ncores * cluster_num();

    int remain = other_size % nthreads;
    int step_easy = (other_size - remain) / nthreads;
    int step_hard = step_easy + 1;
    int step = (thread_id < remain ? step_hard : step_easy);
    int ind_start = (thread_id < remain ? thread_id * step_hard : remain * step_hard + (thread_id - remain) * step_easy);

    constexpr int buf_size = 256;
    __local__ T x_local[buf_size];
    __local__ T y_local[buf_size];
    __local__ T sin_local[buf_size];
    __local__ T cos_local[buf_size];
    __local__ Tindex pos_local[1];

    int remain_dhead = dhead % buf_size;
    int repeat = (dhead - remain_dhead) / buf_size;

    for(int i = ind_start; i < ind_start + step; i++){
        int ind_i = i;
        int ind_d = 0;
        int ind_s = 0;
        ind_d += (ind_i % nhead) * y_stride_nhead;
        ind_s += (ind_i % nhead) * x_stride_nhead;
        ind_i /= nhead;
        ind_d += (ind_i % seqlen) * y_stride_seqlen;
        ind_s += (ind_i % seqlen) * x_stride_seqlen;
        GM2LM(pos_ids + (ind_i % seqlen), pos_local, 1 * sizeof(Tindex));
        int index = static_cast<int>(pos_local[0]) * dhead / 2;
        for(int r = 0; r < repeat + (remain_dhead > 0 ? 1 : 0); r++){
            int read_len = (r < repeat ? buf_size : remain_dhead);
            int dk = read_len / 2;
            int start_d = ind_d + r * buf_size;
            int start_s = ind_s + r * buf_size;
            int sin_cos_index = index + r * buf_size / 2;
            GM2LM(source + start_s, x_local, read_len * sizeof(T));
            GM2LM(sin_table + sin_cos_index, sin_local, dk * sizeof(T));
            GM2LM(cos_table + sin_cos_index, cos_local, dk * sizeof(T));
            if constexpr (xpu_std::is_same<T, float>::value || xpu_std::is_same<T, half>::value){
                for(int k = 0; k < dk; k++){
                    y_local[2 * k] = x_local[2 * k] * cos_local[k] - x_local[2 * k + 1] * sin_local[k];
                    y_local[2 * k + 1] = x_local[2 * k] * sin_local[k] + x_local[2 * k + 1] * cos_local[k];
                }
            }
            /***
            else if(xpu_std::is_same<T, bfloat16_t>::value){
                for(int k = 0; k < dk; k++){
                    float x_0 = __bfloat162float(x_local[2 * k]);
                    float x_1 = __bfloat162float(x_local[2 * k + 1]);
                    float sin_f = __bfloat162float(sin_local[k]);
                    float cos_f = __bfloat162float(cos_local[k]);
                    y_local[2 * k] = __float2bfloat16(x_0 * cos_f - x_1 * sin_f);
                    y_local[2 * k + 1] = __float2bfloat16(x_0 * sin_f + x_1 * cos_f);
                }
            }
            ***/
            mfence();
            LM2GM(y_local, destination + start_d, read_len * sizeof(T));
        }
    }
}

template <typename T, typename Tindex>
void ropeKunlun(void *destination, const void *source, 
                const void *pos_ids, const void *sin_table, const void *cos_table, 
                kunlun_size_t seqlen,  kunlun_size_t nhead, kunlun_size_t dhead,
                const kunlun_ptrdiff_t *x_strides, const kunlun_ptrdiff_t *y_strides){
    XPUStream stream;
    int err = xpu_stream_create(&stream);
    kunlun_ptrdiff_t x_stride_seqlen = (kunlun_ptrdiff_t)x_strides[0];
    kunlun_ptrdiff_t x_stride_nhead = (kunlun_ptrdiff_t)x_strides[1];
    kunlun_ptrdiff_t y_stride_seqlen = (kunlun_ptrdiff_t)y_strides[0];
    kunlun_ptrdiff_t y_stride_nhead = (kunlun_ptrdiff_t)y_strides[1];
    RoPEKernel<T, Tindex><<<8, 64, stream>>>((T *)destination, (T *)source, 
                (Tindex *)pos_ids, (T *)sin_table, (T *)cos_table, 
                seqlen,  nhead, dhead,
                x_stride_seqlen, x_stride_nhead,
                y_stride_seqlen, y_stride_nhead, stream);
      
    xpu_wait(stream); 
}

extern "C" void rope_kunlun(void *destination, const void *source, 
                const void *pos_ids, const void *sin_table, const void *cos_table, 
                kunlun_size_t nt,  kunlun_size_t nh, kunlun_size_t dh,
                const kunlun_ptrdiff_t *x_strides, const kunlun_ptrdiff_t *y_strides, int byteSize)
{      
    if (byteSize == 4){
        ropeKunlun<float, int>(destination, source, 
                pos_ids, sin_table, cos_table, 
                nt, nh, dh,
                x_strides, y_strides);
    }
    else if (byteSize == 2){
        ropeKunlun<half, int>(destination, source, 
                pos_ids, sin_table, cos_table, 
                nt, nh, dh,
                x_strides, y_strides);
    }    
}

