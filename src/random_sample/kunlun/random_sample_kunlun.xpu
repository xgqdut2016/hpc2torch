#include "kunlun/reduce_kunlun.h"
#include "kunlun/sort_kunlun.h"
template <typename Tval, typename Tcompute, typename Tidx>
__device__ void sample(__global_ptr__ Tidx *result,
                       __global_ptr__ Tidx *indices_global,
                       __global_ptr__ Tval *values_global,
                       __local__ Tval *values_local,
                       Tval max_value,
                       Tcompute all_sum,
                       float random_val,
                       float topp,
                       float temperature,
                       int topk,
                       int buf_size) {
    int cid = core_id();
    if (cid >= core_num()) {
        return;
    }
    int thread_id = core_num() * cluster_id() + cid;
    if (thread_id == 0) {

        int end = topk;
        float cumsum = 0.0f;

        for (int r = 0; r < topk / buf_size + (topk % buf_size > 0 ? 1 : 0); r++) {
            int read_len = (r < topk / buf_size ? buf_size : topk % buf_size);
            GM2LM(values_global + r * buf_size, values_local, read_len * sizeof(Tval));
            for (int index = 0; index < read_len; index++) {
                if constexpr (std::is_same_v<Tval, float>) {
                    cumsum += exp((values_local[index] - max_value) / temperature) / to<float>(all_sum);
                } 
                /***
                else if constexpr (std::is_same_v<Tval, bfloat16_t>) {
                    cumsum += exp((to<float>(values_local[index]) - to<float>(max_value)) / temperature) / to<float>(all_sum);
                } 
                ***/
                else if constexpr (std::is_same_v<Tval, half>) {
                    cumsum += exp((to<float>(values_local[index]) - to<float>(max_value)) / temperature) / to<float>(all_sum);
                }
                if (cumsum >= topp) {
                    end = r * buf_size + index + 1;
                    break;
                }
            }
        }
        random_val *= cumsum;
        cumsum = 0.0f;
        for (int r = 0; r < end / buf_size + (end % buf_size > 0 ? 1 : 0); r++) {
            int read_len = (r < end / buf_size ? buf_size : end % buf_size);
            GM2LM(values_global + r * buf_size, values_local, read_len * sizeof(Tval));
            for (int index = 0; index < read_len; index++) {
                if constexpr (std::is_same_v<Tval, float>) {
                    cumsum += exp((values_local[index] - max_value) / temperature) / to<float>(all_sum);
                } 
                /***
                else if constexpr (std::is_same_v<Tval, bfloat16_t>) {
                    cumsum += exp((to<float>(values_local[index]) - to<float>(max_value)) / temperature) / to<float>(all_sum);
                } 
                ***/
                else if constexpr (std::is_same_v<Tval, half>) {
                    cumsum += exp((to<float>(values_local[index]) - to<float>(max_value)) / temperature) / to<float>(all_sum);
                }
                if (random_val < cumsum) {
                    result[0] = indices_global[r * buf_size + index];
                    break;
                }
            }
        }
    }
}
template <unsigned int CLUSTER_SIZE, unsigned int BLOCK_SIZE, typename Tval, typename Tcompute, typename Tidx>
__global__ void random_sampleKernel(Tidx *result,
                                    const Tval *probs,
                                    float random_val,
                                    float topp,
                                    int voc,
                                    int topk,
                                    float temperature,
                                    Tidx *indices,
                                    Tval *values,
                                    Tidx *indices_global,
                                    Tval *values_global,
                                    Tcompute *sum_global) {
    constexpr int buf_size = 128;
    __local__ Tval values_local[2 * buf_size];
    __local__ Tidx indices_local[2 * buf_size];
    TopkKernel<Tval, Tidx>(values,
                           indices,
                           indices_global,
                           values_global,
                           values_local,
                           indices_local,
                           voc,
                           topk,
                           buf_size);
    sync_cluster();
    // 上面这部分是计算topk，数据分别存储在values_global,indices_global里面

    Tval max_value;
    GM2LM(values_global, &max_value, sizeof(Tval));
    sync_cluster();

    __shared__ Tval x_sm[SM_SIZE / sizeof(Tval)];
    __shared__ Tval y_sm[SM_SIZE / sizeof(Tval)];

    Tcompute all_sum = softmaxSum<CLUSTER_SIZE, BLOCK_SIZE, Tval, Tcompute>(probs,
                                                                            max_value,
                                                                            x_sm,
                                                                            y_sm,
                                                                            temperature,
                                                                            voc,
                                                                            sum_global);
    sample<Tval, Tcompute, Tidx>(result, indices_global, values_global, values_local, max_value, all_sum, random_val, topp, temperature, topk, buf_size);
    
}

template <typename Tval, typename Tidx>
__global__ void argmaxKernel(Tidx *result, const Tval *probs, int voc, 
                                    Tidx *indices,
                                    Tval *values,
                                    Tidx *indices_global,
                                    Tval *values_global){
    constexpr int buf_size = 128;
    __local__ Tval values_local[2 * buf_size];
    __local__ Tidx indices_local[2 * buf_size];
    TopOneKernel<Tval, Tidx>(result,
                             values,
                             indices,
                             indices_global,
                             values_global,
                             values_local,
                             indices_local,
                             voc,
                             buf_size);
}
template <typename Tval, typename Tcompute, typename Tidx>
void randomSampleKunlunDevice(void *result,
                  const void *probs,
                  float random_val,
                  float topp,
                  int voc,
                  int topk,
                  float temperature,
                  //xdnn::Context *handle,
                  XPUStream stream)
{
    
    int topk_ = topk <= voc ? topk : voc;
    bool dosample = topk_ > 1 && temperature != 0.0f && topp != 0.0f && random_val != 0.0f;
    constexpr unsigned int cluster_num = 8;
    constexpr unsigned int core_num = 64;
    size_t workspace_size = (voc + cluster_num * core_num * topk_ ) * (sizeof(Tval) + sizeof(Tidx)) + cluster_num * sizeof(Tcompute);
    char *workspace_value;
    xpu_malloc((void **)(&workspace_value), workspace_size);
    
    Tval *values = (Tval *)workspace_value;// [voc]
    xpu_memcpy(values, probs, voc * sizeof(Tval), XPU_DEVICE_TO_DEVICE);
    Tval *values_global = values + voc;//[cluster_num * core_num * topk_]
    char *workspace_sum = workspace_value + (voc + cluster_num * core_num * topk_) * sizeof(Tval);
    Tcompute *sum_global = (Tcompute *)workspace_sum;
    char *workspace_index = workspace_sum + cluster_num * sizeof(Tcompute);
    Tidx *indices = (Tidx *)workspace_index;//[voc]
    Tidx *indices_global = indices + voc;//[cluster_num * core_num * topk_]
    if (dosample)
    {
        random_sampleKernel<cluster_num, core_num, Tval, Tcompute, Tidx><<<cluster_num, core_num, stream>>>((Tidx *)result,
                                                                                               (Tval *)probs,
                                                                                               random_val,
                                                                                               topp,
                                                                                               voc,
                                                                                               topk_,
                                                                                               temperature,
                                                                                               indices,
                                                                                               values,
                                                                                               indices_global,
                                                                                               values_global,
                                                                                                sum_global);
        xpu_wait(stream);                                                                                        
        
    }
    else{
        argmaxKernel<Tval, Tidx><<<cluster_num, core_num, stream>>>((Tidx *)result, (Tval *)probs, voc, 
                                    indices,
                                    values,
                                    indices_global,
                                    values_global);
        xpu_wait(stream);                            
    }    
}
#define LAUNCH_KERNEL(Tval, Tcompute, Tidx)                         \
    randomSampleKunlunDevice<Tval, Tcompute, Tidx>(result, probs, random_val, topp, voc, topk, temperature, stream);

template <typename Tval, typename Tidx>
void randomSampleKunlun(void *result,
                  const void *probs,
                  float random_val,
                  float topp,
                  int voc,
                  int topk,
                  float temperature){
                
    //auto handle = xdnn::create_context();
    XPUStream stream;
    int err = xpu_stream_create(&stream);
    if (sizeof(Tval) == 2){
        LAUNCH_KERNEL(half, float, Tidx);                   
    }
    else if (sizeof(Tval) == 4){
        LAUNCH_KERNEL(Tval, float, Tidx);                 
    }
    
    //destroy_context(handle);
}
extern "C" void randomSample_kunlun(void *result,
                                  const void *probs,
                                  float random_val,
                                  float topp,
                                  int voc,
                                  int topk,
                                  float temperature,
                                  int byteSize)
{

    if (byteSize == 2)
    {

        randomSampleKunlun<uint16_t, int>(result,
                               probs,
                               random_val,
                               topp,
                               voc,
                               topk,
                               temperature);
    }
    else
    {
        randomSampleKunlun<float, int>(result,
                            probs,
                            random_val,
                            topp,
                            voc,
                            topk,
                            temperature);
    }
}